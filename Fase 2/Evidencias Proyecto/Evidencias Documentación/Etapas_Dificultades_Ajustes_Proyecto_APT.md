# ETAPAS, DIFICULTADES Y AJUSTES DEL PROYECTO APT
## Sistema de Gestión de Procesos de Reclutamiento y Selección
### CAPSTONE_001D - Grupo 6

---

## DESCRIPCIÓN DE LAS ETAPAS O ACTIVIDADES DEL PROYECTO APT

El proyecto APT se desarrolló siguiendo una metodología en cascada estructurada en cinco fases principales distribuidas a lo largo de 18 semanas, coincidiendo con el periodo de práctica profesional. La primera fase, correspondiente a planificación y análisis, se desarrolló durante las semanas 1 y 2, donde se establecieron las bases conceptuales y funcionales del sistema mediante la definición completa de requerimientos y alcance. En esta etapa, todo el equipo trabajó de manera colaborativa en el levantamiento de requerimientos funcionales y no funcionales, la definición del alcance del proyecto, la especificación de objetivos y la elaboración completa de la Especificación de Requerimientos de Software (ERS). Estos documentos establecieron una base sólida que permitió avanzar con certeza en las fases siguientes, eliminando ambigüedades y proporcionando una guía clara para el desarrollo.

Posteriormente, durante las semanas 3 a 6, se desarrolló la fase de diseño, donde se crearon los prototipos de baja fidelidad y el diseño completo en Figma de todas las interfaces del sistema. En paralelo, se diseñó el modelo de datos mediante un Modelo Entidad-Relación (MER) que identificó las 39 entidades principales y sus relaciones, se realizó la normalización de la base de datos aplicando las formas normales para eliminar redundancias, y se definió la arquitectura de la solución y del software, incluyendo el diseño del modelo de clases. Esta fase fue fundamental para establecer las especificaciones técnicas antes de iniciar el desarrollo, permitiendo que cada integrante del equipo comprendiera completamente la estructura del sistema y evitando cambios estructurales costosos durante la implementación.

La fase de desarrollo, que abarcó las semanas 7 a 16, constituyó el núcleo del proyecto y se dividió en siete módulos principales. El primer módulo, desarrollado por Aldo en el backend y Nicolas en el frontend durante las semanas 7 y 8, implementó el sistema completo de autenticación y roles, incluyendo JWT, middleware de autenticación, sistema de roles y permisos, endpoints de login y logout, recuperación de contraseña, página de login, protección de rutas y manejo de sesiones. Simultáneamente, Gabriela desarrolló el perfil de administrador con la creación de solicitudes, gestión de clientes y contactos, y gestión de usuarios, mientras que Nicolas implementó el perfil del consultor con la gestión de solicitudes asignadas y el dashboard personalizado.

Durante las semanas 9 y 10, Aldo desarrolló el Módulo 1 correspondiente a la visualización de solicitud y cargo, incluyendo la funcionalidad de transición al siguiente módulo. En las semanas 10 a 12, Nicolas implementó el Módulo 2 de registro de candidatos y publicación, que incluyó la gestión completa de candidatos con toda su información personal, formación académica y experiencia laboral, la carga de CVs, la gestión de portales de publicación y la gestión de postulaciones, culminando con la funcionalidad de paso al módulo siguiente. El Módulo 3, desarrollado por Aldo en las semanas 12 y 13, implementó la presentación de candidatos al cliente, incluyendo el registro de envío, recepción de respuestas del cliente, sistema de comentarios, gestión de estados de postulación, revisión por rechazo total, cierre de procesos Long List y transición al módulo de evaluación.

Gabriela desarrolló el Módulo 4 de evaluación psicolaboral durante las semanas 13 y 14, implementando la creación de evaluaciones, gestión de estados de entrevista, estado del informe, asociación de tests aplicados, resultado global, cierre de procesos independientes, gestión de referencias laborales y transición al módulo final. El Módulo 5, también desarrollado por Gabriela en las semanas 14 y 15, implementó la gestión completa de contrataciones, incluyendo estados avanzados de postulación, registro de contratación, comentarios del cliente, gestión de vacantes, lógica de retorno al módulo 2 o cierre, y cierre exitoso del proceso completo. Durante las semanas 15 y 16, Nicolas desarrolló el Módulo 6 de alertas, control de plazos y registro de actividades, implementando la definición de plazos operativos, alertas automáticas por hito, alertas por atrasos, registro de actividad y trazabilidad, registro automático mediante triggers de base de datos, y el sistema completo de auditoría de gestión de usuarios.

Finalmente, Aldo desarrolló el Módulo 7 de reportes y dashboard durante la semana 16, con colaboración del equipo completo, implementando el dashboard operativo general, reportes de cumplimiento de plazos, estado general de procesos, carga operativa por consultor, efectividad por portal de origen, análisis de retrasos por consultor, y el diseño del modelo dimensional (OLAP) para análisis futuro. Las fases 4 y 5, correspondientes a pruebas y despliegue durante las semanas 17 y 18, y cierre en la semana 18, incluyeron las pruebas de calidad unitarias y de aceptación, el despliegue controlado y capacitación de usuarios, y la documentación final del proyecto.

---

## DIFICULTADES Y FACILITADORES EN EL DESARROLLO DEL PROYECTO APT

El desarrollo del proyecto APT contó con diversos elementos que facilitaron significativamente el avance y la calidad del trabajo, así como dificultades que fueron abordadas mediante ajustes y mejoras continuas. Entre los facilitadores más importantes se encontró la existencia de requerimientos bien definidos desde el inicio del proyecto, establecidos en la ERS completa y detallada, lo que eliminó la necesidad de iteraciones de refinamiento de requisitos y permitió avanzar sin ambigüedades, facilitando la planificación precisa de tiempos y recursos. El stack tecnológico moderno y bien documentado, incluyendo TypeScript que proporcionó tipado estático previniendo errores tempranos, Next.js y React que ofrecieron una base sólida, y Sequelize ORM que simplificó la gestión de base de datos, junto con la amplia documentación y comunidad de soporte disponible, facilitaron enormemente el desarrollo.

La arquitectura en capas bien definida, con separación clara entre controladores, servicios y modelos, facilitó el trabajo en paralelo entre integrantes del equipo, permitiendo mantenibilidad y escalabilidad del código. La distribución clara de responsabilidades, con asignación específica de módulos por integrante, redujo conflictos y duplicación de trabajo, permitiendo especialización en áreas específicas. La metodología en cascada resultó apropiada para el contexto del proyecto, alineada con requerimientos estables y plazo fijo, permitiendo planificación precisa y control del avance, facilitando la coordinación con disponibilidad parcial del equipo. La documentación previa sólida, incluyendo modelo de base de datos bien diseñado desde el inicio y prototipos de interfaz aprobados antes del desarrollo, redujo cambios estructurales costosos durante la implementación.

Sin embargo, el proyecto enfrentó diversas dificultades técnicas que requirieron atención y ajustes. La complejidad de relaciones entre los 39 modelos del sistema, con relaciones complejas de muchos a muchos y uno a muchos, dificultó la implementación de consultas eficientes y la gestión de transacciones, especialmente en casos como la relación entre Candidato, Postulacion, Solicitud y múltiples estados que requería cuidados especiales en las consultas. El cálculo de días hábiles y plazos, considerando solo días hábiles excluyendo fines de semana y feriados, requirió implementar lógica compleja de cálculo de fechas mediante la utilidad `FechasLaborales` con integración de feriados. La sincronización de estado entre frontend y backend generó bugs donde el frontend mostraba datos desactualizados, especialmente en estados de solicitudes que no se actualizaban correctamente después de cambios.

La gestión de archivos, específicamente el almacenamiento y recuperación eficiente de CVs en formato PDF, requirió optimización de almacenamiento y gestión de memoria, balanceando calidad y tamaño de archivos. Las consultas complejas con múltiples joins y filtros complejos resultaron lentas en algunos casos, afectando la experiencia de usuario, especialmente en consultas de hitos con filtros por consultor, estado y tipo de servicio. La normalización de RUTs, con diferentes formatos (con o sin guión, espacios, mayúsculas o minúsculas), causó problemas en comparaciones y filtros, impidiendo que las alertas se mostraran para algunos consultores debido a diferencias de formato.

En cuanto a dificultades organizacionales, la disponibilidad parcial del equipo debido a que el proyecto coincidía con el periodo de práctica profesional limitó la coordinación y reuniones sincrónicas, requiriendo trabajo asíncrono con documentación clara de avances. La distribución de carga de trabajo presentó desbalances temporales, ya que algunos módulos eran más complejos que otros, como el Módulo 2 de Registro de Candidatos que tenía más actividades que otros módulos. La integración de módulos desarrollados en paralelo por diferentes integrantes requirió tiempo adicional para asegurar compatibilidad y mantener consistencia en estilos de código y patrones.

Entre las dificultades de proceso, surgieron cambios en requerimientos durante el desarrollo, aunque estaban definidos inicialmente, lo que requirió adaptación sin comprometer el cronograma, como el cambio de cálculo de plazos de sumar hitos a duraciones fijas por servicio. La gestión de auditoría y trazabilidad requirió modificar múltiples servicios para incluir `setDatabaseUser`, asegurando que todas las operaciones críticas registraran el usuario correcto. El testing y validación en tiempo limitado resultó en que algunos bugs se descubrieran tarde en el proceso, requiriendo testing continuo durante el desarrollo. La documentación durante el desarrollo requirió disciplina para mantener documentación actualizada mientras se desarrollaba, balanceando desarrollo y documentación.

---

## AJUSTES REALIZADOS

Durante el desarrollo del proyecto se realizaron varios ajustes para abordar las dificultades encontradas y mejorar la calidad del sistema, todos ellos realizados dentro de las fases correspondientes sin comprometer la estructura general de la metodología en cascada. El primer ajuste significativo fue en el cálculo de plazos máximos, donde inicialmente se consideró calcular `plazo_maximo_solicitud` sumando las duraciones de los hitos del proceso, pero se identificó que este enfoque no reflejaba la duración real del proceso, dificultaba el mantenimiento al depender de la estructura de hitos, y no estaba alineado con la experiencia real del negocio. Se establecieron entonces duraciones fijas por tipo de servicio basadas en la experiencia de LL Consulting, creando la utilidad `obtenerDuracionProceso()` con duraciones predefinidas que van desde 1 día hábil para Test Psicolaboral hasta 26 días hábiles para Headhunting, integrando esta funcionalidad con `FechasLaborales.sumarDiasHabiles()` para cálculo preciso, resultando en mayor precisión en estimaciones, simplicidad en mantenimiento y alineación con procesos reales del negocio.

El sistema de alertas fue objeto de un ajuste importante cuando se identificó que mostraba hitos de procesos congelados o cancelados, generando ruido innecesario y reduciendo la utilidad del sistema. Se modificaron los métodos `getHitosVencidos`, `getHitosPorVencer`, `getHitosPendientes` y `getHitosCompletados` en `hitoSolicitudService.ts` para incluir `EstadoSolicitudHist` y `EstadoSolicitud` en las consultas, implementando filtrado automático para excluir hitos de solicitudes con estado 'congelado' o 'cancelado', validando el estado actual del proceso antes de incluir hitos en alertas, resultando en un sistema de alertas más relevante y útil enfocado solo en procesos activos.

El sistema de auditoría requirió un ajuste significativo cuando se identificó que algunas operaciones registraban usuario genérico "avnadmin" en lugar del usuario real responsable, comprometiendo la trazabilidad completa y el cumplimiento de requisitos de auditoría. Se realizó una revisión completa de todos los servicios críticos, implementando `setDatabaseUser(usuarioRut, transaction)` en múltiples servicios incluyendo `hitoSolicitudService.copiarPlantillasASolicitud`, `estadoClienteM5Service.cambiarEstado`, `postulacionService.createPostulacion`, `candidatoService.createCandidato`, y múltiples métodos de `evaluacionPsicolaboralService`, actualizando los controladores para pasar `req.user?.id` a los servicios y validando que todas las operaciones críticas registraran el usuario correcto, logrando trazabilidad completa de todas las operaciones y cumplimiento de requisitos de auditoría.

La optimización de rendimiento del frontend se abordó mediante la implementación de un sistema de caché en memoria (`SimpleCache`) en `api.ts`, debido a que se identificaron múltiples llamadas redundantes a la API para datos estáticos como regiones, comunas, profesiones, instituciones, portales y estados de solicitud, reduciendo rendimiento y generando carga innecesaria del servidor. Se implementó caché para estos datos estáticos con TTL de 10 horas mediante el método `getOrFetch()` que verifica caché antes de hacer llamada API, resultando en reducción significativa de llamadas API y mejora en rendimiento y experiencia de usuario.

La normalización de RUTs se abordó creando la función `normalizarRut()` en `hitoSolicitudService.ts` para estandarizar el formato eliminando guiones, espacios y convirtiendo a mayúsculas, aplicando esta normalización en todas las comparaciones de RUT y mejorando el logging para debugging de comparaciones, resultando en comparaciones de RUT consistentes, filtros funcionando correctamente y alertas mostrándose para todos los consultores. La visualización de hitos se corrigió cuando se identificó que hitos con `fecha_cumplimiento` se mostraban como "Pendiente" en la timeline, corrigiendo la lógica de mapeo en `app/consultor/proceso/[id]/page.tsx` para priorizar `fecha_cumplimiento` para determinar estado 'completado', estableciendo el orden correcto de verificación como completado, vencido, en_progreso y pendiente, resultando en timeline mostrando correctamente el estado de los hitos.

El dashboard de administrador se corrigió cuando se identificó que las estadísticas no se cargaban mostrando valores en cero, modificando `useSolicitudes.ts` para calcular estadísticas dinámicamente mediante la función `fetchStatsAndServiceTypes()` que obtiene todas las solicitudes, calcula total, en_progreso, completadas y pendientes según estado, actualizando el estado del hook con llamada automática al montar componente y en refresh, resultando en dashboard mostrando estadísticas reales y actualizadas. El sistema de alertas de administrador se mejoró cuando se identificó que los filtros de servicio y consultor no funcionaban correctamente y faltaba información en las alertas, corrigiendo `serviceCodeLabels` con mapeo completo de códigos de servicio, cambiando de `userService.getAll()` a `descripcionCargoService.getFormData()` para obtener consultores, implementando `getUltimoHitoActivoPorProceso()` para mostrar solo último hito activo por proceso, y añadiendo nombre del consultor y tipo de servicio en las tarjetas de alerta, resultando en filtros funcionando correctamente, información completa en alertas y mejor experiencia de usuario.

Finalmente, se realizó una limpieza sistemática del código eliminando logs excesivos de depuración en producción que afectaban claridad y rendimiento, eliminando múltiples `console.log`, `console.error` y `Logger.info` en código de producción en archivos como `candidatoService.ts`, `solicitudService.ts`, `hitoSolicitudService.ts`, `feriadosService.ts`, `server.ts`, `connectionManager.ts` y múltiples controladores, manteniendo logs estructurados con `Logger` solo para información relevante y usando niveles apropiados, resultando en código más limpio, logs relevantes y mejor mantenibilidad.

Estos ajustes demuestran la flexibilidad necesaria incluso dentro de una metodología en cascada, siendo incrementales sin requerir retroceder a fases anteriores, enfocados en mejorar funcionalidad y experiencia de usuario, realizados dentro de los tiempos asignados sin impacto en cronograma, y basados en feedback respondiendo a problemas reales identificados durante desarrollo y pruebas. Las lecciones aprendidas incluyen que la metodología en cascada no es rígida y permite ajustes dentro de las fases, que la validación continua durante el desarrollo es esencial, que los ajustes incrementales mejoran la calidad sin comprometer la estructura, y que la comunicación efectiva permite identificar y abordar problemas tempranamente.

---

**Fecha de elaboración**: Noviembre 2025  
**Versión del documento**: 1.0
