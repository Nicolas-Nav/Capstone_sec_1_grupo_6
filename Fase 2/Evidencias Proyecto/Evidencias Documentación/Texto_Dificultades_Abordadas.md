# TEXTO: DIFICULTADES Y CÓMO SE ABORDARON
## Para sección de Desarrollo del Informe Final

---

El proyecto también enfrentó diversas dificultades técnicas y organizacionales. Entre ellas: la complejidad de las relaciones entre los 39 modelos, lo que dificultó consultas y transacciones; problemas de sincronización entre frontend y backend que generaron datos desactualizados; gestión de archivos PDF y optimización de consultas con múltiples joins; inconsistencias en el formato de RUT que afectaron filtros y alertas; limitada disponibilidad del equipo por coincidir con la práctica profesional; diferencias en carga de trabajo entre módulos y desafíos en la integración; y testing limitado que llevó a descubrir errores en etapas tardías.

Estas dificultades fueron abordadas mediante estrategias técnicas y organizacionales que permitieron mantener el avance del proyecto sin comprometer la calidad. La complejidad de las relaciones entre modelos se resolvió mediante el uso cuidadoso de transacciones atómicas en Sequelize, la implementación de includes selectivos en las consultas para evitar sobrecarga, y la creación de servicios especializados que encapsularon la lógica de negocio compleja, permitiendo manejar las relaciones de manera controlada y eficiente. Los problemas de sincronización entre frontend y backend se solucionaron mediante la implementación de un sistema de caché en memoria para datos estáticos con TTL configurable, la optimización de las llamadas API mediante el método `getOrFetch()` que verifica caché antes de realizar peticiones, y la implementación de hooks personalizados que gestionan el estado de manera eficiente, reduciendo significativamente las llamadas redundantes y mejorando la consistencia de los datos mostrados.

La gestión de archivos PDF se optimizó mediante la implementación de almacenamiento eficiente en base de datos con validación de tamaño y formato, balanceando calidad y tamaño de archivos para evitar sobrecarga del sistema. Las consultas complejas con múltiples joins se optimizaron mediante la creación de índices en campos frecuentemente consultados, el uso de includes selectivos en Sequelize que cargan solo las relaciones necesarias, y la implementación de paginación en endpoints que manejan grandes volúmenes de datos, mejorando significativamente los tiempos de respuesta.

Las inconsistencias en el formato de RUT se resolvieron mediante la creación de una función `normalizarRut()` que estandariza el formato eliminando guiones, espacios y convirtiendo a mayúsculas, aplicando esta normalización en todas las comparaciones y filtros del sistema, lo que permitió que las alertas y filtros funcionaran correctamente para todos los consultores independientemente del formato de entrada. La limitada disponibilidad del equipo se abordó mediante la implementación de trabajo asíncrono con documentación clara de avances, el uso de herramientas de control de versiones que facilitaron la colaboración sin necesidad de reuniones constantes, y la asignación clara de responsabilidades por módulo que permitió que cada integrante trabajara de manera independiente en su área, coordinándose solo en puntos de integración específicos.

Las diferencias en carga de trabajo entre módulos se equilibraron mediante la redistribución de tareas cuando fue necesario, la colaboración entre integrantes en módulos más complejos como el Módulo 2 de Registro de Candidatos, y la flexibilidad en la asignación de responsabilidades que permitió apoyar a quien requería más tiempo. Los desafíos en la integración se resolvieron mediante la definición de interfaces claras entre módulos desde el diseño, la implementación de pruebas de integración continuas durante el desarrollo, y la comunicación proactiva entre integrantes para identificar y resolver incompatibilidades tempranamente.

El testing limitado se abordó mediante la implementación de pruebas continuas durante el desarrollo en lugar de dejarlas solo para el final, la creación de casos de prueba para funcionalidades críticas, y la validación constante con el cliente durante el desarrollo que permitió identificar y corregir errores antes de que se acumularan. Adicionalmente, se implementó un sistema de logging estructurado que facilitó la identificación y corrección de problemas, y se realizó una limpieza sistemática del código eliminando logs de depuración excesivos que dificultaban la identificación de errores reales.

En general, el proyecto avanzó exitosamente gracias a una planificación sólida, una buena arquitectura y una adecuada distribución de tareas, enfrentando las dificultades mediante coordinación efectiva, documentación clara, ajustes técnicos continuos y una actitud proactiva del equipo para identificar y resolver problemas de manera temprana, lo que permitió mantener la calidad del sistema y cumplir con los objetivos establecidos dentro del plazo previsto.

